<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Circuit Lab - Professional Edition</title>
    <style>
        :root {
            /* Palette */
            --bg-app: #f1f5f9;          /* Slate 100 */
            --bg-panel: #ffffff;        /* White */
            --primary-grad: linear-gradient(135deg, #4f46e5 0%, #0ea5e9 100%); /* Indigo to Sky */
            --primary-solid: #4f46e5;
            --accent-color: #f59e0b;    /* Amber 500 */
            --text-main: #1e293b;       /* Slate 800 */
            --text-muted: #64748b;      /* Slate 500 */
            --border-light: #e2e8f0;    /* Slate 200 */
            --danger: #ef4444;
            --success: #10b981;
            
            /* Dimensions */
            --header-height: 64px;
            --sidebar-width: 280px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-app);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- Header --- */
        header {
            height: var(--header-height);
            background: var(--primary-grad);
            color: white;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 30;
            flex-shrink: 0;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand-icon {
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        h1 { margin: 0; font-size: 1.25rem; font-weight: 600; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; opacity: 0.9; font-weight: 400; }

        /* --- Layout --- */
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            z-index: 20;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.02);
        }

        .panel-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-light);
        }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            font-weight: 700;
            margin-bottom: 12px;
        }

        .instruction-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 12px;
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.5;
            border: 1px solid var(--border-light);
        }
        .instruction-card strong { color: var(--primary-solid); }

        /* Toolbox Grid */
        .tools-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .tool-card {
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .tool-card:hover {
            border-color: #a5b4fc;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.08);
            transform: translateY(-1px);
        }

        .tool-card:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .tool-icon-wrapper {
            width: 48px;
            height: 48px;
            background: #f1f5f9;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
        }
        
        .tool-info {
            display: flex;
            flex-direction: column;
        }

        .tool-name { font-weight: 600; font-size: 0.95rem; color: var(--text-main); }
        .tool-desc { font-size: 0.75rem; color: var(--text-muted); margin-top: 2px; }

        /* Delete Toggle */
        .delete-btn {
            margin-top: auto;
            margin-bottom: 20px;
            width: calc(100% - 40px);
            align-self: center;
            padding: 12px;
            background-color: white;
            border: 2px solid var(--danger);
            color: var(--danger);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.1);
        }
        
        .delete-btn:hover { background-color: #fef2f2; }
        
        .delete-btn.active {
            background-color: var(--danger);
            color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            background-color: var(--bg-app);
            position: relative;
            /* Subtle Pattern Background */
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 24px 24px;
        }

        @media (max-width: 900px) {
            .workspace { flex-direction: column; }
            .sidebar { width: 80px; }
            .tool-info, .section-title, .instruction-card, .subtitle { display: none; }
            .tool-card { justify-content: center; padding: 8px; }
            .tool-icon-wrapper { margin: 0; }
            .delete-btn span { display: none; }
        }

        /* --- Zones --- */
        .zone-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border: 1px solid white;
        }

        .zone-top-bar {
            padding: 12px 20px;
            background: #ffffff;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zone-label {
            font-weight: 700;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .zone-badge {
            background: #e0e7ff;
            color: #4338ca;
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            font-weight: 800;
        }

        .clear-btn {
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }
        .clear-btn:hover {
            background: #fee2e2;
            color: var(--danger);
            border-color: #fca5a5;
        }

        .zone-canvas {
            flex: 1;
            position: relative;
            /* Engineering Graph Paper Look */
            background-color: #ffffff;
            background-image: 
                linear-gradient(to right, #f1f5f9 1px, transparent 1px),
                linear-gradient(to bottom, #f1f5f9 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
        }

        /* Black Box Styling */
        .black-box-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px; 
            height: 180px;
            border: 2px dashed #cbd5e1;
            background-color: rgba(248, 250, 252, 0.8);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none; 
            z-index: 0;
            color: #94a3b8;
        }
        
        .black-box-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.5;
        }
        .black-box-text {
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        /* --- Components --- */
        .component {
            position: absolute;
            height: 40px; 
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transform-origin: center center;
            pointer-events: none; 
        }

        .comp-body {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            cursor: grab;
            pointer-events: auto;
        }
        .comp-body:active { cursor: grabbing; }

        /* Delete Mode Visuals */
        body.delete-mode .comp-body {
            cursor: not-allowed;
            border: 1px dashed var(--danger);
            background-color: rgba(239, 68, 68, 0.1);
            border-radius: 4px;
        }
        body.delete-mode .handle { display: none; }

        /* Handles */
        .handle {
            position: absolute;
            width: 16px; height: 16px;
            background-color: transparent;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: crosshair;
            z-index: 20;
            pointer-events: auto;
        }
        .handle::after {
            content: '';
            position: absolute;
            top: 4px; left: 4px; width: 8px; height: 8px;
            background-color: white;
            border: 2px solid var(--primary-solid);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .handle:hover::after { background-color: var(--primary-solid); transform: scale(1.3); }
        .h-start { left: 0; }
        .h-end { left: 100%; }

        /* Connection Dot */
        .connection-dot {
            position: absolute;
            width: 12px; height: 12px;
            background-color: var(--text-main);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 0 2px white;
        }

        /* Snap Indicator */
        .snap-indicator {
            position: absolute;
            width: 24px; height: 24px;
            border: 2px solid var(--success);
            background-color: rgba(16, 185, 129, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            pointer-events: none;
            display: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.6; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* SVG Components */
        .comp-svg { width: 100%; height: 100%; overflow: visible; pointer-events: none; }
        
        .circuit-line { stroke: #334155; stroke-width: 3; fill: none; stroke-linecap: round; stroke-linejoin: round; }
        .bulb-circle { fill: white; stroke: #334155; stroke-width: 2; }
        .bulb-filament { stroke: #475569; stroke-width: 1.5; fill: none; }
        .battery-pos { stroke: #ef4444; stroke-width: 3; } 
        .battery-neg { stroke: #334155; stroke-width: 3; } 
        
        /* Removed CSS blur filter, using SVG gradient instead for iPad compatibility */
        .light-ray { stroke: var(--accent-color); stroke-width: 2; stroke-linecap: round; opacity: 0; transition: opacity 0.2s; }

        /* Warning Toast */
        .warning {
            position: absolute;
            bottom: 20px; right: 20px;
            background-color: #fee2e2;
            color: #991b1b;
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 0.85rem;
            font-weight: 700;
            border: 1px solid #fca5a5;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 30;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

<header>
    <div class="brand">
        <div class="brand-icon">‚ö°</div>
        <div>
            <h1>Circuit Lab</h1>
        </div>
    </div>
    <div class="subtitle">Professional Edition</div>
</header>

<div class="container">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="panel-section">
            <div class="section-title">Instructions</div>
            <div class="instruction-card">
                <div>‚Ä¢ Drag items to connect.</div>
                <div style="margin-top:4px">‚Ä¢ <strong>Double-click</strong> to delete.</div>
                <div style="margin-top:4px">‚Ä¢ Max <strong>4 Bulbs</strong> per zone.</div>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">Components</div>
            <div class="tools-grid">
                <!-- Battery Tool -->
                <div class="tool-card" ontouchstart="startDragNew(event, 'BATTERY')" onmousedown="startDragNew(event, 'BATTERY')">
                    <div class="tool-icon-wrapper">
                        <svg viewBox="0 0 40 40" width="30" height="30">
                            <line x1="5" y1="20" x2="15" y2="20" stroke="#334155" stroke-width="2" />
                            <line x1="25" y1="20" x2="35" y2="20" stroke="#334155" stroke-width="2" />
                            <line x1="15" y1="12" x2="15" y2="28" stroke="#334155" stroke-width="2" /> 
                            <line x1="25" y1="15" x2="25" y2="25" stroke="#ef4444" stroke-width="4" /> 
                        </svg>
                    </div>
                    <div class="tool-info">
                        <span class="tool-name">Battery</span>
                        <span class="tool-desc">9V DC Source</span>
                    </div>
                </div>

                <!-- Bulb Tool -->
                <div class="tool-card" ontouchstart="startDragNew(event, 'BULB')" onmousedown="startDragNew(event, 'BULB')">
                    <div class="tool-icon-wrapper">
                        <svg viewBox="0 0 40 40" width="30" height="30">
                            <circle cx="20" cy="20" r="8" stroke="#334155" stroke-width="2" fill="none" />
                            <path d="M 14 20 Q 20 10 26 20" stroke="#334155" stroke-width="2" fill="none" />
                            <line x1="4" y1="20" x2="12" y2="20" stroke="#334155" stroke-width="2" />
                            <line x1="28" y1="20" x2="36" y2="20" stroke="#334155" stroke-width="2" />
                        </svg>
                    </div>
                    <div class="tool-info">
                        <span class="tool-name">Light Bulb</span>
                        <span class="tool-desc">Resistive Load</span>
                    </div>
                </div>

                <!-- Wire Tool -->
                <div class="tool-card" ontouchstart="startDragNew(event, 'WIRE')" onmousedown="startDragNew(event, 'WIRE')">
                    <div class="tool-icon-wrapper">
                        <svg viewBox="0 0 40 40" width="30" height="30">
                            <line x1="5" y1="20" x2="35" y2="20" stroke="#334155" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </div>
                    <div class="tool-info">
                        <span class="tool-name">Wire</span>
                        <span class="tool-desc">Connector</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="delete-btn" onclick="toggleDeleteMode()" id="deleteBtn">
            <span id="delIcon">üóëÔ∏è</span> <span id="delText">Delete Mode</span>
        </div>
    </aside>

    <!-- Workspace -->
    <main class="workspace">
        <!-- Zone 1 -->
        <div class="zone-wrapper">
            <div class="zone-top-bar">
                <div class="zone-label">
                    <span class="zone-badge">Zone A</span>
                </div>
                <button class="clear-btn" onclick="resetZone(1)">Clear</button>
            </div>
            <div class="zone-canvas" id="zone1">
                <div class="black-box-area">
                    <div class="black-box-icon">‚ùñ</div>
                    <div class="black-box-text">Black Box A</div>
                </div>
                <div id="dots-zone1"></div> 
                <div id="snap-zone1" class="snap-indicator"></div>
                <div id="warning-zone1" class="warning">‚ö†Ô∏è Short Circuit Detected!</div>
            </div>
        </div>

        <!-- Zone 2 -->
        <div class="zone-wrapper">
            <div class="zone-top-bar">
                <div class="zone-label">
                    <span class="zone-badge">Zone B</span>
                </div>
                <button class="clear-btn" onclick="resetZone(2)">Clear</button>
            </div>
            <div class="zone-canvas" id="zone2">
                <div class="black-box-area">
                    <div class="black-box-icon">‚ùñ</div>
                    <div class="black-box-text">Black Box B</div>
                </div>
                <div id="dots-zone2"></div>
                <div id="snap-zone2" class="snap-indicator"></div>
                <div id="warning-zone2" class="warning">‚ö†Ô∏è Short Circuit Detected!</div>
            </div>
        </div>
    </main>
</div>

<script>
    // --- Constants ---
    const SNAP_DIST = 30; 
    const NODE_MERGE_DIST = 15; 
    const DEFAULT_LENGTH = 100;

    // --- State ---
    let components = []; 
    let dragInfo = null;
    let idCounter = 0;
    let isDeleteMode = false;

    // --- Delete Logic ---
    function toggleDeleteMode() {
        isDeleteMode = !isDeleteMode;
        const btn = document.getElementById('deleteBtn');
        const txt = document.getElementById('delText');
        if (isDeleteMode) {
            btn.classList.add('active');
            txt.innerText = "Done Deleting";
            document.body.classList.add('delete-mode');
        } else {
            btn.classList.remove('active');
            txt.innerText = "Delete Mode";
            document.body.classList.remove('delete-mode');
        }
    }

    function removeComponent(id) {
        const c = components.find(x => x.id === id);
        if(c) {
            c.element.remove();
            components = components.filter(x => x.id !== id);
            updateCircuit();
        }
    }

    // --- Drag & Drop Logic ---

    function getPointerPos(e) {
        if (e.touches) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }

    function startDragNew(e, type) {
        if (isDeleteMode) return;
        e.preventDefault(); 
        const pos = getPointerPos(e);
        
        const ghost = document.createElement('div');
        ghost.className = 'component';
        ghost.style.width = DEFAULT_LENGTH + 'px';
        ghost.style.pointerEvents = 'none';
        ghost.style.opacity = '0.7';
        ghost.style.left = (pos.x - DEFAULT_LENGTH/2) + 'px';
        ghost.style.top = (pos.y - 20) + 'px';
        
        // Simple SVG preview for ghost
        ghost.innerHTML = `<div style="width:100%; height:2px; background:#333; margin-top:19px;"></div>`;
        
        document.body.appendChild(ghost);

        dragInfo = {
            mode: 'NEW',
            type: type,
            element: ghost,
            offsetX: DEFAULT_LENGTH/2,
            offsetY: 20
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('touchend', onEnd);
    }

    function startDragExisting(e, id, handleType) {
        if (isDeleteMode) {
            removeComponent(id);
            return;
        }

        e.preventDefault();
        e.stopPropagation();
        
        const comp = components.find(c => c.id === id);
        if(!comp) return;

        const pos = getPointerPos(e);
        const zone = document.getElementById('zone' + comp.zoneId);
        const zoneRect = zone.getBoundingClientRect();

        let startX, startY;
        
        if (handleType === 'BODY') {
            startX = pos.x - (zoneRect.left + comp.x1);
            startY = pos.y - (zoneRect.top + comp.y1);
        } else {
            startX = 0; startY = 0;
        }

        dragInfo = {
            mode: handleType, 
            id: id,
            comp: comp,
            zoneRect: zoneRect,
            startPointerX: pos.x,
            startPointerY: pos.y,
            initialX1: comp.x1,
            initialY1: comp.y1,
            initialX2: comp.x2,
            initialY2: comp.y2
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('touchend', onEnd);
    }

    function onMove(e) {
        if (!dragInfo) return;
        e.preventDefault();
        const pos = getPointerPos(e);

        // Hide snap indicators initially
        document.getElementById('snap-zone1').style.display = 'none';
        document.getElementById('snap-zone2').style.display = 'none';

        if (dragInfo.mode === 'NEW') {
            dragInfo.element.style.left = (pos.x - dragInfo.offsetX) + 'px';
            dragInfo.element.style.top = (pos.y - dragInfo.offsetY) + 'px';
        } 
        else {
            const dx = pos.x - dragInfo.startPointerX;
            const dy = pos.y - dragInfo.startPointerY;
            const c = dragInfo.comp;

            if (dragInfo.mode === 'BODY') {
                c.x1 = dragInfo.initialX1 + dx;
                c.y1 = dragInfo.initialY1 + dy;
                c.x2 = dragInfo.initialX2 + dx;
                c.y2 = dragInfo.initialY2 + dy;
                
                const s1 = findSnap(c.x1, c.y1, c.zoneId, c.id);
                const s2 = findSnap(c.x2, c.y2, c.zoneId, c.id);
                if(s1) showSnapIndicator(c.zoneId, s1.x, s1.y);
                else if(s2) showSnapIndicator(c.zoneId, s2.x, s2.y);

            } else if (dragInfo.mode === 'START') {
                c.x1 = dragInfo.initialX1 + dx;
                c.y1 = dragInfo.initialY1 + dy;
                const s = findSnap(c.x1, c.y1, c.zoneId, c.id);
                if(s) showSnapIndicator(c.zoneId, s.x, s.y);

            } else if (dragInfo.mode === 'END') {
                c.x2 = dragInfo.initialX2 + dx;
                c.y2 = dragInfo.initialY2 + dy;
                const s = findSnap(c.x2, c.y2, c.zoneId, c.id);
                if(s) showSnapIndicator(c.zoneId, s.x, s.y);
            }
            
            updateComponentVisuals(c);
        }
    }

    function showSnapIndicator(zoneId, x, y) {
        const ind = document.getElementById('snap-zone' + zoneId);
        ind.style.display = 'block';
        ind.style.left = x + 'px';
        ind.style.top = y + 'px';
    }

    function onEnd(e) {
        if (!dragInfo) return;

        document.getElementById('snap-zone1').style.display = 'none';
        document.getElementById('snap-zone2').style.display = 'none';

        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('mouseup', onEnd);
        document.removeEventListener('touchend', onEnd);

        if (dragInfo.mode === 'NEW') {
            const rect = dragInfo.element.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;

            const z1 = document.getElementById('zone1').getBoundingClientRect();
            const z2 = document.getElementById('zone2').getBoundingClientRect();

            let zoneId = null;
            let zoneRect = null;

            if (centerX >= z1.left && centerX <= z1.right && centerY >= z1.top && centerY <= z1.bottom) {
                zoneId = 1; zoneRect = z1;
            } else if (centerX >= z2.left && centerX <= z2.right && centerY >= z2.top && centerY <= z2.bottom) {
                zoneId = 2; zoneRect = z2;
            }

            dragInfo.element.remove();

            if (zoneId) {
                const relCX = centerX - zoneRect.left;
                const relCY = centerY - zoneRect.top;
                
                const x1 = relCX - DEFAULT_LENGTH/2;
                const x2 = relCX + DEFAULT_LENGTH/2;
                const y1 = relCY;
                const y2 = relCY;

                if (checkLimits(zoneId, dragInfo.type)) {
                    createComponent(dragInfo.type, x1, y1, x2, y2, zoneId);
                }
            }
        } else {
            const c = dragInfo.comp;
            
            if (dragInfo.mode === 'START' || dragInfo.mode === 'BODY') {
                const snap = findSnap(c.x1, c.y1, c.zoneId, c.id);
                if (snap) { 
                    c.x1 = snap.x; 
                    c.y1 = snap.y;
                    if (snap.type === 'EDGE') splitWire(snap.targetComp, snap.x, snap.y);
                }
            }
            
            if (dragInfo.mode === 'END' || dragInfo.mode === 'BODY') {
                const snap = findSnap(c.x2, c.y2, c.zoneId, c.id);
                if (snap) { 
                    c.x2 = snap.x; 
                    c.y2 = snap.y; 
                    if (snap.type === 'EDGE') splitWire(snap.targetComp, snap.x, snap.y);
                }
            }

            updateComponentVisuals(c);
        }

        dragInfo = null;
        updateCircuit();
    }

    function splitWire(targetComp, splitX, splitY) {
        targetComp.element.remove();
        components = components.filter(c => c.id !== targetComp.id);
        createComponent('WIRE', targetComp.x1, targetComp.y1, splitX, splitY, targetComp.zoneId);
        createComponent('WIRE', splitX, splitY, targetComp.x2, targetComp.y2, targetComp.zoneId);
    }

    function findSnap(x, y, zoneId, selfId) {
        const others = components.filter(c => c.zoneId === zoneId && c.id !== selfId);
        
        // Priority: Nodes
        for (let o of others) {
            if (dist(x, y, o.x1, o.y1) < SNAP_DIST) return { x: o.x1, y: o.y1, type: 'NODE' };
            if (dist(x, y, o.x2, o.y2) < SNAP_DIST) return { x: o.x2, y: o.y2, type: 'NODE' };
        }

        // Secondary: Edges
        if (dragInfo && (dragInfo.mode === 'START' || dragInfo.mode === 'END')) {
            for (let o of others) {
                if (o.type === 'WIRE') {
                    const closest = getClosestPointOnSegment({x, y}, {x: o.x1, y: o.y1}, {x: o.x2, y: o.y2});
                    if (closest.dist < SNAP_DIST) {
                        const d1 = dist(closest.x, closest.y, o.x1, o.y1);
                        const d2 = dist(closest.x, closest.y, o.x2, o.y2);
                        if (d1 > 10 && d2 > 10) {
                            return { x: closest.x, y: closest.y, type: 'EDGE', targetComp: o };
                        }
                    }
                }
            }
        }
        return null;
    }

    function getClosestPointOnSegment(p, a, b) {
        const atob = { x: b.x - a.x, y: b.y - a.y };
        const atop = { x: p.x - a.x, y: p.y - a.y };
        const lenSq = atob.x * atob.x + atob.y * atob.y;
        let dot = atop.x * atob.x + atop.y * atob.y;
        let t = Math.min(1, Math.max(0, dot / lenSq));
        return { x: a.x + atob.x * t, y: a.y + atob.y * t, dist: dist(p.x, p.y, a.x + atob.x * t, a.y + atob.y * t) };
    }

    function dist(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    }

    function checkLimits(zoneId, type) {
        const zoneComps = components.filter(c => c.zoneId === zoneId);
        if (type === 'BATTERY') {
            if (zoneComps.some(c => c.type === 'BATTERY')) {
                alert("Only 1 Battery allowed per zone.");
                return false;
            }
        }
        if (type === 'BULB') {
            if (zoneComps.filter(c => c.type === 'BULB').length >= 4) {
                alert("Max 4 Bulbs allowed per zone.");
                return false;
            }
        }
        return true;
    }

    function createComponent(type, x1, y1, x2, y2, zoneId) {
        const id = ++idCounter;
        
        const div = document.createElement('div');
        div.className = 'component';
        
        const body = document.createElement('div');
        body.className = 'comp-body';
        body.addEventListener('mousedown', (e) => startDragExisting(e, id, 'BODY'));
        body.addEventListener('touchstart', (e) => startDragExisting(e, id, 'BODY'));
        
        // Double click/tap to delete
        body.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            removeComponent(id);
        });
        let lastTap = 0;
        body.addEventListener('touchend', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0) {
                e.stopPropagation();
                removeComponent(id);
            }
            lastTap = currentTime;
        });

        div.appendChild(body);

        const h1 = document.createElement('div'); h1.className = 'handle h-start';
        h1.addEventListener('mousedown', (e) => startDragExisting(e, id, 'START'));
        h1.addEventListener('touchstart', (e) => startDragExisting(e, id, 'START'));
        
        const h2 = document.createElement('div'); h2.className = 'handle h-end';
        h2.addEventListener('mousedown', (e) => startDragExisting(e, id, 'END'));
        h2.addEventListener('touchstart', (e) => startDragExisting(e, id, 'END'));

        div.appendChild(h1);
        div.appendChild(h2);

        const svgContainer = document.createElement('div');
        svgContainer.className = 'comp-svg-container';
        svgContainer.style.width = '100%';
        svgContainer.style.height = '100%';
        svgContainer.style.pointerEvents = 'none';
        div.appendChild(svgContainer);

        document.getElementById('zone' + zoneId).appendChild(div);

        const comp = { id, type, x1, y1, x2, y2, zoneId, element: div, svgContainer };
        components.push(comp);
        
        updateComponentVisuals(comp);
    }

    function updateComponentVisuals(comp) {
        const dx = comp.x2 - comp.x1;
        const dy = comp.y2 - comp.y1;
        const length = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        
        const mx = (comp.x1 + comp.x2) / 2;
        const my = (comp.y1 + comp.y2) / 2;

        comp.element.style.width = length + 'px';
        comp.element.style.left = (mx - length/2) + 'px';
        comp.element.style.top = (my - 20) + 'px'; 
        comp.element.style.transform = `rotate(${angle}deg)`;

        comp.svgContainer.innerHTML = getSVG(comp.type, length, 0);
    }

    function resetZone(zoneId) {
        const toRemove = components.filter(c => c.zoneId === zoneId);
        toRemove.forEach(c => c.element.remove());
        components = components.filter(c => c.zoneId !== zoneId);
        updateCircuit();
    }

    function getSVG(type, width, brightness) {
        const cx = width / 2;
        const cy = 20;

        let content = '';

        if (type === 'WIRE') {
            content = `<line x1="0" y1="20" x2="${width}" y2="20" class="circuit-line" />`;
        } 
        else if (type === 'BATTERY') {
            const gap = 10;
            const leftEnd = cx - gap/2;
            const rightStart = cx + gap/2;
            
            content = `
                <line x1="0" y1="20" x2="${leftEnd}" y2="20" class="circuit-line" />
                <line x1="${rightStart}" y1="20" x2="${width}" y2="20" class="circuit-line" />
                <line x1="${leftEnd}" y1="5" x2="${leftEnd}" y2="35" class="battery-pos" />
                <line x1="${rightStart}" y1="12" x2="${rightStart}" y2="28" class="battery-neg" />
                <text x="${leftEnd - 12}" y="10" font-size="12" font-family="sans-serif" fill="#ef4444" font-weight="bold">+</text>
            `;
        } 
        else if (type === 'BULB') {
            const r = 14;
            const leftEnd = cx - r;
            const rightStart = cx + r;
            
            const opacity = Math.min(brightness, 1);
            const glowR = 20 + (brightness * 20); 
            
            // Unique ID for gradient to avoid conflicts
            const gradId = 'glow-' + Math.floor(Math.random() * 100000);

            let rays = '';
            if (brightness > 0.1) {
                const numRays = 8 + Math.floor(brightness * 8);
                const rayLen = 10 + (brightness * 15);
                const inner = r + 4;
                
                for(let i=0; i<numRays; i++) {
                    const ang = (i / numRays) * Math.PI * 2;
                    const r1x = cx + Math.cos(ang) * inner;
                    const r1y = cy + Math.sin(ang) * inner;
                    const r2x = cx + Math.cos(ang) * (inner + rayLen);
                    const r2y = cy + Math.sin(ang) * (inner + rayLen);
                    rays += `<line x1="${r1x}" y1="${r1y}" x2="${r2x}" y2="${r2y}" class="light-ray" style="opacity: ${opacity}" />`;
                }
            }

            content = `
                <defs>
                    <radialGradient id="${gradId}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:var(--accent-color); stop-opacity: ${opacity * 0.8}" />
                        <stop offset="100%" style="stop-color:var(--accent-color); stop-opacity: 0" />
                    </radialGradient>
                </defs>
                
                <circle cx="${cx}" cy="${cy}" r="${glowR}" fill="url(#${gradId})" />
                ${rays}
                <line x1="0" y1="20" x2="${leftEnd}" y2="20" class="circuit-line" />
                <line x1="${rightStart}" y1="20" x2="${width}" y2="20" class="circuit-line" />
                <circle cx="${cx}" cy="${cy}" r="${r}" class="bulb-circle" />
                <path d="M ${cx-r+2} 20 Q ${cx} 0 ${cx+r-2} 20" class="bulb-filament" />
            `;
        }

        return `<svg class="comp-svg" viewBox="0 0 ${width} 40" preserveAspectRatio="xMidYMid meet">${content}</svg>`;
    }

    // --- Physics Engine (Robust MNA with Shunt Resistors) ---

    function updateCircuit() {
        solveZone(1);
        solveZone(2);
    }

    function solveZone(zoneId) {
        const zoneComps = components.filter(c => c.zoneId === zoneId);
        const warningEl = document.getElementById('warning-zone' + zoneId);
        const dotsContainer = document.getElementById('dots-zone' + zoneId);
        
        // Reset Visuals
        warningEl.style.display = 'none';
        dotsContainer.innerHTML = '';
        zoneComps.forEach(c => {
            if(c.type === 'BULB') {
                const dx = c.x2 - c.x1;
                const dy = c.y2 - c.y1;
                const len = Math.sqrt(dx*dx + dy*dy);
                c.svgContainer.innerHTML = getSVG('BULB', len, 0);
            }
        });

        if (zoneComps.length === 0) return;

        // 1. Identify Nodes
        let nodes = []; 

        function getNodeIndex(x, y) {
            for(let i=0; i<nodes.length; i++) {
                if (dist(nodes[i].x, nodes[i].y, x, y) < NODE_MERGE_DIST) {
                    return i;
                }
            }
            nodes.push({x, y});
            return nodes.length - 1;
        }

        // Find Battery Negative to set as Ground (Node 0)
        const batt = zoneComps.find(c => c.type === 'BATTERY');
        if (batt) {
            getNodeIndex(batt.x2, batt.y2); // Force Battery Negative to be Node 0
        }

        // Build element list
        let elements = [];
        zoneComps.forEach(c => {
            const n1 = getNodeIndex(c.x1, c.y1);
            const n2 = getNodeIndex(c.x2, c.y2);

            if (c.type === 'BATTERY') {
                elements.push({ type: 'V', n1: n1, n2: n2, value: 9 });
            } else if (c.type === 'BULB') {
                elements.push({ type: 'R', n1: n1, n2: n2, value: 10, comp: c }); 
            } else if (c.type === 'WIRE') {
                elements.push({ type: 'R', n1: n1, n2: n2, value: 0.001 }); 
            }
        });

        // Draw Connection Dots
        nodes.forEach(n => {
            let count = 0;
            elements.forEach(el => {
                if(el.n1 === nodes.indexOf(n) || el.n2 === nodes.indexOf(n)) count++;
            });
            if(count > 1) {
                const dot = document.createElement('div');
                dot.className = 'connection-dot';
                dot.style.left = n.x + 'px';
                dot.style.top = n.y + 'px';
                dotsContainer.appendChild(dot);
            }
        });

        // If no battery or no circuit, stop
        if (!batt || nodes.length < 2) return;

        // 2. Build Matrix (MNA)
        const numNodes = nodes.length;
        const numV = elements.filter(e => e.type === 'V').length;
        const size = numNodes + numV;
        
        let G = Array(size).fill(0).map(() => Array(size).fill(0));
        let I = Array(size).fill(0);

        let vIndex = numNodes;

        // Add Shunt Conductance (Gmin) to diagonal
        const GMIN = 1e-9; 
        for(let i=0; i<numNodes; i++) {
            G[i][i] += GMIN;
        }

        elements.forEach(el => {
            const { n1, n2, type, value } = el;
            
            if (type === 'R') {
                const g = 1/value;
                G[n1][n1] += g;
                G[n2][n2] += g;
                G[n1][n2] -= g;
                G[n2][n1] -= g;
            } else if (type === 'V') {
                G[n1][vIndex] += 1; 
                G[n2][vIndex] -= 1; 
                G[vIndex][n1] += 1;
                G[vIndex][n2] -= 1;
                I[vIndex] = value;
                vIndex++;
            }
        });

        // Ground Node 0
        for(let i=0; i<size; i++) {
            G[0][i] = 0;
            G[i][0] = 0; 
        }
        G[0][0] = 1;
        I[0] = 0;

        // 3. Solve
        const voltages = solveMatrix(G, I);
        if (!voltages) return;

        // 4. Apply Results
        let totalCurrent = 0;

        elements.forEach(el => {
            if (el.type === 'R' && el.comp) {
                const vDrop = Math.abs(voltages[el.n1] - voltages[el.n2]);
                // Brightness calc
                let b = (vDrop * vDrop) / 40; 
                
                const dx = el.comp.x2 - el.comp.x1;
                const dy = el.comp.y2 - el.comp.y1;
                const len = Math.sqrt(dx*dx + dy*dy);
                
                el.comp.svgContainer.innerHTML = getSVG('BULB', len, b);
            }
        });
        
        // Check Short Circuit
        for(let i=numNodes; i<size; i++) {
            totalCurrent += Math.abs(voltages[i]);
        }
        
        if (totalCurrent > 200) {
            warningEl.style.display = 'flex';
        }
    }

    function solveMatrix(A, b) {
        const n = A.length;
        let M = A.map(row => [...row]);
        let x = [...b];

        for (let i = 0; i < n; i++) {
            let maxEl = Math.abs(M[i][i]);
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(M[k][i]) > maxEl) {
                    maxEl = Math.abs(M[k][i]);
                    maxRow = k;
                }
            }

            for (let k = i; k < n; k++) {
                let tmp = M[maxRow][k];
                M[maxRow][k] = M[i][k];
                M[i][k] = tmp;
            }
            let tmp = x[maxRow];
            x[maxRow] = x[i];
            x[i] = tmp;

            if (Math.abs(M[i][i]) < 1e-12) return null; 

            for (let k = i + 1; k < n; k++) {
                let c = -M[k][i] / M[i][i];
                for (let j = i; j < n; j++) {
                    if (i === j) M[k][j] = 0;
                    else M[k][j] += c * M[i][j];
                }
                x[k] += c * x[i];
            }
        }

        let res = new Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
            let sum = 0;
            for (let j = i + 1; j < n; j++) {
                sum += M[i][j] * res[j];
            }
            res[i] = (x[i] - sum) / M[i][i];
        }
        return res;
    }

</script>

</body>
</html>